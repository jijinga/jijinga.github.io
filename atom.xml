<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寂静</title>
  
  
  <link href="https://jijinga.github.io/atom.xml" rel="self"/>
  
  <link href="https://jijinga.github.io/"/>
  <updated>2021-03-14T03:19:38.283Z</updated>
  <id>https://jijinga.github.io/</id>
  
  <author>
    <name>寂静</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单实现一些vue原理</title>
    <link href="https://jijinga.github.io/2021/03/14/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9Bvue%E5%8E%9F%E7%90%86/"/>
    <id>https://jijinga.github.io/2021/03/14/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9Bvue%E5%8E%9F%E7%90%86/</id>
    <published>2021-03-14T02:53:04.000Z</published>
    <updated>2021-03-14T03:19:38.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h2><p>首先实现一个简单的 observer 方法，实现对数据更新的监控。对象的监控通过<code>Object.defineProperty</code>方法实现，数组的监控通过重写数组原型上的方法实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.create(arrayProto); <span class="comment">// 自己的原型</span></span><br><span class="line">[<span class="string">&quot;push&quot;</span>, <span class="string">&quot;unshift&quot;</span>, <span class="string">&quot;splice&quot;</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  proto[method] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> inserted; <span class="comment">// 将插入的数据</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;unshift&quot;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>); <span class="comment">// 第三个参数开始才是插入的数据</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">    ArrayObserver(inserted);</span><br><span class="line">    arrayProto[method].call(<span class="built_in">this</span>, ...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayObserver</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 数组的处理方式</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, proto); <span class="comment">// 改变原型指向</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = obj[i];</span><br><span class="line">    observer(item); <span class="comment">// 数组中的对象也应该监听</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先确保必须是对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">    ArrayObserver(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      defineReactive(obj, key, obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归多层对象</span></span><br><span class="line">  observer(value);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">        observer(newValue);</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let data = &#123; name: &#123; n: &quot;jijing&quot; &#125; &#125;;</span></span><br><span class="line"><span class="comment">// observer(data);</span></span><br><span class="line"><span class="comment">// data.name.n = &quot;123&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;;</span><br><span class="line">observer(data);</span><br><span class="line">data.arr.push(&#123; <span class="attr">name</span>: <span class="string">&quot;123&quot;</span> &#125;);</span><br><span class="line">data.arr[<span class="number">3</span>].name = <span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch 实际上调用了 vm.$watch</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span>(<span class="params">watch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    vm.$watch(key, watch[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">initWatch(&#123;</span><br><span class="line">  <span class="function"><span class="title">name</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newVal);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">demo</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// vm.name = xxx</span></span><br><span class="line"><span class="comment">// xxx</span></span><br></pre></td></tr></table></figure><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>computed 实际上也是通过<code>Object.defineProperty</code>方法给 vm 对象上新增属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dirty = <span class="literal">true</span>; <span class="comment">// 缓存作用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">key, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = handler();</span><br><span class="line">        dirty = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initComputed(<span class="string">&quot;fullName&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> vm.name + <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vm.fullName);</span><br><span class="line"><span class="comment">// xxx + aaa</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;observer&quot;&gt;&lt;a href=&quot;#observer&quot; class=&quot;headerlink&quot; title=&quot;observer&quot;&gt;&lt;/a&gt;observer&lt;/h2&gt;&lt;p&gt;首先实现一个简单的 observer 方法，实现对数据更新的监控。对象的监控通过&lt;code&gt;</summary>
      
    
    
    
    <category term="原理实现" scheme="https://jijinga.github.io/categories/%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="Vue" scheme="https://jijinga.github.io/tags/Vue/"/>
    
    <category term="前端" scheme="https://jijinga.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>总结一些面试题</title>
    <link href="https://jijinga.github.io/2021/03/05/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://jijinga.github.io/2021/03/05/%E6%80%BB%E7%BB%93%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-05T06:50:32.000Z</published>
    <updated>2021-03-05T12:51:24.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Vue2-x中数据响应式具体是如何实现的。"><a href="#1-Vue2-x中数据响应式具体是如何实现的。" class="headerlink" title="1.Vue2.x中数据响应式具体是如何实现的。"></a>1.Vue2.x中数据响应式具体是如何实现的。</h3><p>Vue采用数据劫持结合发布订阅模式的方式来实现数据的响应式，vue在初始化的时候，在initState方法中会调取initData方法初始化data数据，对data对象进行遍历，在这个方法中会调observer（监听器，观察者）对data中的数据进行监听，在observer中对数据进行判断，如果是数组执行observerArray深度进行监听，继续执行observer方法，如果当前传入的是对象则执行this.walk，对对象进行循环，重新定义对象的属性，这时使用的就是<code>defineReactive</code>，它是vue中的一个核心方法，用来定义响应式。在defineReactive方法中实例化了一个Dep（发布者），通过<code>Object.defineProperty</code>对数据进行拦截，把这些 property 全部转为 getter/setter。get数据的时候，通过dep.depend触发Watcher（订阅者）的依赖收集，收集订阅者，如果数据是数组，执行dependArray，对数组中的每个值通过depend都添加到依赖。set时，会对数据进行比较，如果数据发生了变化会通过dep.notify发布通知，通知watcher，更新视图。</p><h3 id="对SPA单页面应用的理解，以及优缺点"><a href="#对SPA单页面应用的理解，以及优缺点" class="headerlink" title="对SPA单页面应用的理解，以及优缺点"></a>对SPA单页面应用的理解，以及优缺点</h3><p>SPA单页面应用仅在页面初始化时加载相应的资源文件。一旦加载完成，就不会因为用户的操作重新加载页面或者跳转。取而代之的是利用路由机制实现页面的切换，UI与用户的交互，避免页面的重载。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>用户体验好、快，内容的改变不需要重载页面，避免了不必要的重复渲染</li><li>基于上面一点，SPA相对服务器压力小点</li><li>前后端职责分离，架构清晰。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>首次加载耗时多：为实现单页web应用功能及现实效果，需要在加载页面的时候将js、css统一加载，部分页面按需加载</li><li>SEO难度较大：所有的内容都在一个页面中动态替换显示，不利于SEO</li><li>前进后退路由管理：单页应用在一个页面中显示所有，不能使用浏览器的前进后退功能，所有的页面切换需要自己手动实现</li></ul><h3 id="v-show和v-if有什么区别？切换时会触发哪些生命周期？"><a href="#v-show和v-if有什么区别？切换时会触发哪些生命周期？" class="headerlink" title="v-show和v-if有什么区别？切换时会触发哪些生命周期？"></a>v-show和v-if有什么区别？切换时会触发哪些生命周期？</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><blockquote><p>它会确保在切换过程中条件块内事件监听器和子组件适当地被销毁和重建，惰性渲染。</p></blockquote><h5 id="初始渲染："><a href="#初始渲染：" class="headerlink" title="初始渲染："></a>初始渲染：</h5><p>初始值为 <strong>false</strong> 组件<strong>不会</strong>渲染，生命周期钩子<strong>不会</strong>执行<br>初始值为 <strong>true</strong> 时，组件会进行渲染，并依次执行 ：</p><ol><li>beforeCreate </li><li>created</li><li>beforeMount</li><li>mounted </li></ol><h5 id="切换："><a href="#切换：" class="headerlink" title="切换："></a>切换：</h5><p>false  =&gt;  true<br>依次执行 beforeCreate,created,beforeMount,mounted 生命周期。<br>true =&gt; false<br>依次执行 beforeDestroy,destroyed 生命周期。</p><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote><p>不管初始条件是什么，元素都会被渲染，并且只是简单地基于CSS的‘<strong>dispaly</strong>’属性进行切换。</p></blockquote><h5 id="初始渲染：-1"><a href="#初始渲染：-1" class="headerlink" title="初始渲染："></a>初始渲染：</h5><p>无论初始状态，组件都会渲染，<strong>v-show</strong> 的渲染是<strong>非惰性</strong>的，依次执行</p><ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted </li></ol><h5 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h5><p>对生命周期钩子无影响，切换时组件始终保持在 mounted 钩子。</p><h2 id="3、说说你对MVVM的理解？"><a href="#3、说说你对MVVM的理解？" class="headerlink" title="3、说说你对MVVM的理解？"></a>3、说说你对MVVM的理解？</h2><p>MVVM（Model - View - ViewModel）是一个软件架构设计模式，源于经典的MVC（Modle-View-Controller）模式，MVVM促进了前后端分离，极大的提高了前端的开发效率，核心是ViewModel，他就像一个中转站，负责转换Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Modle层通过接口请求进行数据交互，如图</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/332a2ab3-117a-41d9-8469-93dea4a27856.jpg"></p><h4 id="view层"><a href="#view层" class="headerlink" title="view层"></a>view层</h4><p>VIew是视图层，前端主要由HTML和CSS构建</p><h4 id="Modle层"><a href="#Modle层" class="headerlink" title="Modle层"></a>Modle层</h4><p>MOdel是数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的API接口</p><h4 id="ViewModle层"><a href="#ViewModle层" class="headerlink" title="ViewModle层"></a>ViewModle层</h4><p>ViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。</p><h2 id="4、怎么理解vue的单向数据流？"><a href="#4、怎么理解vue的单向数据流？" class="headerlink" title="4、怎么理解vue的单向数据流？"></a>4、怎么理解vue的单向数据流？</h2><p>所有的prop都使其父子prop之间形成一个单向下行绑定：<strong>父级prop的更新会向下流动到子组件中，但是反向不行</strong>。这样会防止子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解。</p><h4 id="常见的改变prop情形："><a href="#常见的改变prop情形：" class="headerlink" title="常见的改变prop情形："></a>常见的改变prop情形：</h4><ol><li><p>prop用来传递初始值；这个子组件接下来希望将其作为一个本地的prop数据来使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:[<span class="string">&#x27;initNum&#x27;</span>]</span><br><span class="line">data: <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num: <span class="built_in">this</span>.props.initNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个prop以一种原始值传入但需要进行转换。在这种情况下，最好使用这个prop的值来定义一个计算属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:[<span class="string">&#x27;initNum&#x27;</span>]</span><br><span class="line">computed: &#123;</span><br><span class="line">    addNum: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.props.initNum++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、谈谈你对vue生命周期的理解？"><a href="#5、谈谈你对vue生命周期的理解？" class="headerlink" title="5、谈谈你对vue生命周期的理解？"></a>5、谈谈你对vue生命周期的理解？</h2></li></ol><h4 id="什么是生命周期？"><a href="#什么是生命周期？" class="headerlink" title="什么是生命周期？"></a>什么是生命周期？</h4><p>vue实例从创建、初始化数据、编译模板、挂载DOM =&gt; 渲染DOM、更新DOM=&gt;渲染DOM、卸载等一系列过程，称之为vue的生命周期</p><h4 id="各个生命周期作用"><a href="#各个生命周期作用" class="headerlink" title="各个生命周期作用"></a>各个生命周期作用</h4><table><thead><tr><th align="left">生命周期</th><th>描述</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td align="left">created</td><td>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</td></tr><tr><td align="left">beforeMount</td><td>在挂载开始之前调用，相关的render函数首次调用</td></tr><tr><td align="left">mounted</td><td>el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td align="left">beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟dom打补丁之前</td></tr><tr><td align="left">update</td><td>组件数据更新之后</td></tr><tr><td align="left">activited</td><td>keep-alive专属，组件被激活时调用</td></tr><tr><td align="left">deactivated</td><td>kepp-alive专属，组件被销毁时调用</td></tr><tr><td align="left">beforeDestory</td><td>组件销毁前调用</td></tr><tr><td align="left">destoryed</td><td>组件销毁后调用</td></tr></tbody></table><h4 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h4><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/6308bce9-40cf-48c6-b5e7-abfd276e5ae4.png"></p><h2 id="6、computed和watch的区别和运用场景？"><a href="#6、computed和watch的区别和运用场景？" class="headerlink" title="6、computed和watch的区别和运用场景？"></a>6、computed和watch的区别和运用场景？</h2><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>计算属性，依赖其它属性值，并且computed的值有缓存。只有在他依赖的属性值发生改变时，下一次获取computed的值才会重新计算computed的值</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>更多的时“观察”作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调执行后续操作</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><p>当需要进行数值计算，并且依赖于其他数据时，使用computed，利用其缓存特性，避免每次获取值时，都重新计算</p></li><li><p>当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch允许我们执行异步操作</p></li></ul><h2 id="7、谈谈你对keep-alive的了解？"><a href="#7、谈谈你对keep-alive的了解？" class="headerlink" title="7、谈谈你对keep-alive的了解？"></a>7、谈谈你对keep-alive的了解？</h2><p>keep-alive式vue内置的一个组件，可以使用被包含的组件保留状态，避免重新渲染，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件</li><li>提供include和exclude属性，两者都支持字符串或者正则表达式，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高</li><li>对应两个钩子函数activated和deactivated，当组件被激活时，触发钩子函数activated，当组件被移除时，触发钩子函数deactivated</li></ul><h2 id="8、组件中data为什么是一个函数？"><a href="#8、组件中data为什么是一个函数？" class="headerlink" title="8、组件中data为什么是一个函数？"></a>8、组件中data为什么是一个函数？</h2><p>组件是用来复用的，且js里对象是引用关系，如果组件中的data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中的data是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性值不会相互影响；而new vue实例，是不会被复用，因此不存在引用对象的问题</p><h2 id="9、v-model的原理？"><a href="#9、v-model的原理？" class="headerlink" title="9、v-model的原理？"></a>9、v-model的原理？</h2><p>在vue项目中主要用v-model指令在表单input、textarea、select等元素创建双向绑定。v-modle本质上是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text和textarea元素使用value属性和input事件</li><li>checkbook和radio使用checked属性和change事件；</li><li>select字段将value作为prop并将change作为事件</li></ul><h2 id="10、vue组件间通信有哪几种方式？"><a href="#10、vue组件间通信有哪几种方式？" class="headerlink" title="10、vue组件间通信有哪几种方式？"></a>10、vue组件间通信有哪几种方式？</h2><p>vue组件中的通信方式有：父子组件通信、兄弟组件通信、隔代组件通信</p><h4 id="1、props-emit（父子）"><a href="#1、props-emit（父子）" class="headerlink" title="1、props/$emit（父子）"></a>1、props/$emit（父子）</h4><p>父组件向子组件传递数据是通过prop传递，子组件传递数据给父组件是通过$emit触发事件来做到的。适用于父子组件的通信</p><h4 id="2、-emit-on（父子、兄弟、隔代）"><a href="#2、-emit-on（父子、兄弟、隔代）" class="headerlink" title="2、$emit/$on（父子、兄弟、隔代）"></a>2、$emit/$on（父子、兄弟、隔代）</h4><p>这种方法通过一个空的Vue实例作为中央事件总线，用它来触发事件和监听事件，从而实现任何组件的通信，包括父子、隔代、校内各地组件</p><h4 id="3、vuex（父子、兄弟、隔代）"><a href="#3、vuex（父子、兄弟、隔代）" class="headerlink" title="3、vuex（父子、兄弟、隔代）"></a>3、vuex（父子、兄弟、隔代）</h4><p>vuex是一个专门为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store。</p><h4 id="4、ref、-parent-children（父子）"><a href="#4、ref、-parent-children（父子）" class="headerlink" title="4、ref、$parent/$children（父子）"></a>4、ref、$parent/$children（父子）</h4><ul><li>ref: 如果在普通的dom元素上使用，引用指向是dom元素；如果在子组件上，引用就指向组件实例</li><li>$parent/$children: 访问父/子组件实例</li></ul><h4 id="5、-attrs-listeners（隔代）"><a href="#5、-attrs-listeners（隔代）" class="headerlink" title="5、$attrs/$listeners（隔代）"></a>5、$attrs/$listeners（隔代）</h4><ul><li>$attrs: 包含了父作用域中不被prop所识别的特性绑定。通常配合inheritAttrs使用</li><li>$listeners：包含了父作用域中的v-on事件监听器，可以通过v-on=“$listeners”传入组件内部</li></ul><h4 id="6、provide-inject（父子、兄弟、隔代）"><a href="#6、provide-inject（父子、兄弟、隔代）" class="headerlink" title="6、provide/inject（父子、兄弟、隔代）"></a>6、provide/inject（父子、兄弟、隔代）</h4><p>父组件通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用inject那么就可以注入provide中的数据，适用于隔代组件通信。</p><h2 id="11、谈谈你对vuex的理解？"><a href="#11、谈谈你对vuex的理解？" class="headerlink" title="11、谈谈你对vuex的理解？"></a>11、谈谈你对vuex的理解？</h2><p>Vuex是一个专门为Vue.js应用程序开发的一个全局状态管理模式。。每个vuex应用的核心是store。</p><p>（1）vuex的状态管理存储是响应式的。当vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应的得到高校更新</p><p>（2） 改变store中的状态唯一途径就是显式地提交mutation。这样使得我们可以方便地跟踪每一个状态的变化</p><p>主要包含以下几个模块：</p><ul><li>state：定义了应用状态的数据结构，可以在这里设置默认的初始状态</li><li>getter：允许组件从store中获取数据，mapGetters辅助函数仅仅是将store中的getter映射道局部计算属性</li><li>mutation：是唯一更改store中状态的方法，且必须式同步函数</li><li>module：允许将单一的store拆分为多个store且同时保存单一的状态树中</li></ul><h2 id="12、vue-router路由模式有几种？"><a href="#12、vue-router路由模式有几种？" class="headerlink" title="12、vue-router路由模式有几种？"></a>12、vue-router路由模式有几种？</h2><p>vue-router有三种路由模式：hash、history、abstract，对应源码如下图所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="built_in">this</span>.options.base)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="built_in">this</span>.options.base, <span class="built_in">this</span>.fallback)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="built_in">this</span>.options.base)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span>(process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3中路由模式说明：</p><ul><li>hash: 使用url hash值来作为路由。支持所有浏览器</li><li>history：依赖HTML5History API和服务器配置</li><li>abstract：支持所有js运行环境</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Vue2-x中数据响应式具体是如何实现的。&quot;&gt;&lt;a href=&quot;#1-Vue2-x中数据响应式具体是如何实现的。&quot; class=&quot;headerlink&quot; title=&quot;1.Vue2.x中数据响应式具体是如何实现的。&quot;&gt;&lt;/a&gt;1.Vue2.x中数据响应式具体是</summary>
      
    
    
    
    <category term="前端面试" scheme="https://jijinga.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试题" scheme="https://jijinga.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="前端" scheme="https://jijinga.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Elementui中Dropdown组件踩坑</title>
    <link href="https://jijinga.github.io/2021/03/04/Elementui%E4%B8%ADDropdown%E7%BB%84%E4%BB%B6%E8%B8%A9%E5%9D%91/"/>
    <id>https://jijinga.github.io/2021/03/04/Elementui%E4%B8%ADDropdown%E7%BB%84%E4%BB%B6%E8%B8%A9%E5%9D%91/</id>
    <published>2021-03-04T00:11:09.000Z</published>
    <updated>2021-03-04T00:34:40.458Z</updated>
    
    <content type="html"><![CDATA[<p>问题：组件并未正常渲染，且控制台报错。</p><p>报错信息如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span> : Cannot read property <span class="string">&#x27;disabled&#x27;</span> <span class="keyword">of</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-dropdown&gt;</span><br><span class="line">  &lt;el-dropdown-menu slot=<span class="string">&quot;dropdown&quot;</span>&gt;</span><br><span class="line">    &lt;el-dropdown-item&gt;test1&lt;/el-dropdown-item&gt;</span><br><span class="line">    &lt;el-dropdown-item&gt;test2&lt;/el-dropdown-item&gt;</span><br><span class="line">  &lt;/el-dropdown-menu&gt; </span><br><span class="line">&lt;/el-dropdown&gt;</span><br></pre></td></tr></table></figure><p>问题原因：el-dropdown组件没有写完整，补全为如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-dropdown&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    下拉</span><br><span class="line">    &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-icon-arrow-down el-icon--right&quot;</span> /&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">  &lt;el-dropdown-menu slot=<span class="string">&quot;dropdown&quot;</span>&gt;</span><br><span class="line">    &lt;el-dropdown-item&gt;test1&lt;/el-dropdown-item&gt;</span><br><span class="line">    &lt;el-dropdown-item&gt;test2&lt;/el-dropdown-item&gt;</span><br><span class="line">  &lt;/el-dropdown-menu&gt; </span><br><span class="line">&lt;/el-dropdown&gt;</span><br></pre></td></tr></table></figure><p>问题解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题：组件并未正常渲染，且控制台报错。&lt;/p&gt;
&lt;p&gt;报错信息如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Uncaught </summary>
      
    
    
    
    <category term="前端" scheme="https://jijinga.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="项目中的一些问题" scheme="https://jijinga.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="Elemet" scheme="https://jijinga.github.io/tags/Elemet/"/>
    
    <category term="Vue" scheme="https://jijinga.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>高阶函数</title>
    <link href="https://jijinga.github.io/2021/02/10/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://jijinga.github.io/2021/02/10/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2021-02-10T00:49:21.858Z</published>
    <updated>2021-02-10T05:35:23.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><blockquote><p>什么是高阶函数？</p></blockquote><h5 id="1-一个函数的参数，是一个函数（回调函数）"><a href="#1-一个函数的参数，是一个函数（回调函数）" class="headerlink" title="1.一个函数的参数，是一个函数（回调函数）"></a>1.一个函数的参数，是一个函数（回调函数）</h5><h5 id="2-一个函数执行，返回另一个函数（拆分函数）"><a href="#2-一个函数执行，返回另一个函数（拆分函数）" class="headerlink" title="2.一个函数执行，返回另一个函数（拆分函数）"></a>2.一个函数执行，返回另一个函数（拆分函数）</h5><h2 id="before-函数"><a href="#before-函数" class="headerlink" title="before 函数"></a>before 函数</h2><blockquote><p>希望将核心的代码逻辑封装起来， 在外部增加其他的功能.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 在函数的原型上增加before方法，之后创建的函数都可以使用这个方法</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行添加的函数</span></span><br><span class="line">    fn();</span><br><span class="line">    <span class="comment">// 这里的this代表的就是核心函数本身</span></span><br><span class="line">    <span class="built_in">this</span>(...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> say = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我是核心功能&quot;</span>, ...args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSay = say.before(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我是添加的新功能&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">newSay(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><blockquote><p>事务机制就是，当一个操作进行前，做了某件事。当进行后，做了某件事.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perform = <span class="function">(<span class="params">anymethod, wrappers</span>) =&gt;</span> &#123;</span><br><span class="line">  wrappers.forEach(<span class="function"><span class="params">wrap</span> =&gt;</span> &#123;</span><br><span class="line">    wrap.initilizae();</span><br><span class="line">  &#125;);</span><br><span class="line">  anymethod();</span><br><span class="line">  wrappers.forEach(<span class="function"><span class="params">wrap</span> =&gt;</span> &#123;</span><br><span class="line">    wrap.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">perform(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;说话&quot;</span>);</span><br><span class="line">&#125;, [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">initilizae</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;说话之前：你好&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;说话之后：再见&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">initilizae</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;说话之前：你好1&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;说话之后：再见1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>通过以上代码我们可以发现，我们在执行 <code>perform</code> 方法时，传递了一个数组，里面放置了两组不同的方法。</p><p>我们在函数调用时，先调用了所有 <code>initilizae</code> ，也就是调用之前要做的事情，紧接着我们执行了调用时<br>执行的方法，当调用完成时，再调用了所有 <code>close</code> ，也就是调用之后要做的事情。</p><h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h2><blockquote><p>将一个函数拆分为多个函数.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkType = <span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> types = [<span class="string">&quot;Number&quot;</span>, <span class="string">&quot;String&quot;</span>, <span class="string">&quot;Boolean&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">types.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">  utils[<span class="string">&quot;is&quot;</span> + type] = checkType(type);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(utils.isString(<span class="string">&quot;123&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = fn.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    arr = arr.concat(args);</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> curring(fn, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(...arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = curring(add)(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><h2 id="after-函数"><a href="#after-函数" class="headerlink" title="after 函数"></a>after 函数</h2><blockquote><p>当一个函数执行指定次数时，再执行某个方法.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">times, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newAfter = after(<span class="number">3</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;三次后调用&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">newAfter();</span><br><span class="line">newAfter();</span><br><span class="line">newAfter();</span><br></pre></td></tr></table></figure><h2 id="after-函数的实际用法"><a href="#after-函数的实际用法" class="headerlink" title="after 函数的实际用法"></a>after 函数的实际用法</h2><blockquote><p>我们想等待两个文件读取完成之后在做某件事.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> school = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">times, fn</span>) =&gt;</span> <span class="function">() =&gt;</span> --times === <span class="number">0</span> &amp;&amp; fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newAfter = after(<span class="number">2</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(school);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;name.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  school[<span class="string">&quot;name&quot;</span>] = data;</span><br><span class="line">  newAfter();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;age.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  school[<span class="string">&quot;age&quot;</span>] = data;</span><br><span class="line">  newAfter();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><blockquote><p>一个简单的发布订阅例子.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> school = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> e = &#123;</span><br><span class="line">  arr: [],</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.arr.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.arr.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">e.on(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">e.on(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(school).length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(school);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;name.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  school[<span class="string">&quot;name&quot;</span>] = data;</span><br><span class="line">  e.emit(); <span class="comment">// 发布</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;age.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  school[<span class="string">&quot;age&quot;</span>] = data;</span><br><span class="line">  e.emit(); <span class="comment">// 发布</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>观察者模式跟发布订阅有什么不同？</p></blockquote><p>在发布订阅中，发布跟订阅是没有包含关系的，是两个独立的个体，但在观察者模式中，被观察者中包含观察者。<br>观察者模式是包含发布订阅的。来看一个小例子，小宝宝将同时受到父母的观察。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.arr = [];</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;我很开心&quot;</span>; <span class="comment">// 状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">attach</span>(<span class="params">o</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将观察者放到被观察者身上</span></span><br><span class="line">    <span class="built_in">this</span>.arr.push(o);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setState</span>(<span class="params">newState</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = newState;</span><br><span class="line">    <span class="built_in">this</span>.arr.forEach(<span class="function"><span class="params">o</span> =&gt;</span> o.update(newState));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">newState</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;的小宝宝：&quot;</span> + newState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Subject(<span class="string">&quot;小宝宝&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Observer(<span class="string">&quot;我&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Observer(<span class="string">&quot;我媳妇&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.attach(o1);</span><br><span class="line">s.attach(o2);</span><br><span class="line">s.setState(<span class="string">&quot;我不开心了&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;什么是高阶函数？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;1-一个函数的参数，是一个函</summary>
      
    
    
    
    <category term="前端" scheme="https://jijinga.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Javascript" scheme="https://jijinga.github.io/tags/Javascript/"/>
    
    <category term="函数" scheme="https://jijinga.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
